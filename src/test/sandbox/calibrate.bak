 void calibrate (bool debug = false)
  {
    int checker_rows = 7;
    int checker_cols = 9;
    int checker_mm = 35;

    // Creating vector to store vectors of 3D points for each checkerboard image
    std::vector<std::vector<cv::Point3f>> obj_points;
  
    // Creating vector to store vectors of 2D points for each checkerboard image
    std::vector<std::vector<cv::Point2f> > img_points;
  
    // Defining the world coordinates for 3D points
    std::vector<cv::Point3f> objp;
    for (int col = 0; col < checker_cols; col++)
      for (int row = 0; row < checker_rows; row++)
        objp.push_back (cv::Point3f (col * checker_mm, row * checker_mm, 0));
  
    // Extracting image paths
    std::string path = "./checker35mm/*.jpg";
    std::vector<cv::String> image_names;
    cv::glob (path, image_names);

    std::vector<cv::Mat> calib_images;
    for (cv::String image_path : image_names)
    {
      cv::Mat frame = cv::imread (image_path);
      cv::Mat left, right;
      split_frame (frame, left, right);
      calib_images.push_back (left);
      calib_images.push_back (right);
    }
  
    cv::Mat frame, gray;
    std::vector<cv::Point2f> corner_pts;
    bool success;
    int index = 0;
  
    // Looping over all the calibration images
    for (cv::Mat& calib_image : calib_images)
    {
      cv::cvtColor (calib_image, gray, cv::COLOR_BGR2GRAY);
      success = cv::findChessboardCorners (
        gray, 
        cv::Size (checker_cols, checker_rows),
        corner_pts,
        cv::CALIB_CB_ADAPTIVE_THRESH | 
        cv::CALIB_CB_FAST_CHECK |
        cv::CALIB_CB_NORMALIZE_IMAGE);
       
      // If desired number of corner are detected, refine and display pixels
      if (!success)
      {
        std::cout << "FAILURE TO FIND CORNERS" << std::endl;
        continue;
      }

      cv::TermCriteria criteria (
        cv::TermCriteria::EPS | cv::TermCriteria::MAX_ITER,
        30,
        0.001);
      
      // refining pixel coordinates for given 2d points.
      cv::cornerSubPix (
        gray,
        corner_pts,
        cv::Size (11,11),
        cv::Size (-1,-1),
        criteria);
      
      // Displaying the detected corner points on the checker board
      cv::drawChessboardCorners (
        calib_image,
        cv::Size (checker_cols, checker_rows),
        corner_pts, 
        success);
      
      obj_points.push_back (objp);
      img_points.push_back (corner_pts);
  
      if (debug)
      {
        std::string out_path = "./checker35mm/out/c" + std::to_string (index / 2) 
                                + "_" + std::to_string (index % 2 + 1) + ".jpg";
        cv::imwrite (out_path, calib_image);

        ++index;
      }
    }
  
    std::vector<cv::Mat> rvecs, tvecs;  // Vectors, not single Mat!
    float rms_error = cv::calibrateCamera (
      obj_points,
      img_points,
      cv::Size (gray.cols, gray.rows),
      intrinsic_mat, 
      distortion, 
      rvecs,
      tvecs);
  
    if (debug)
    {
      std::cout << "cameraMatrix : " << intrinsic_mat << std::endl;
      std::cout << "distCoeffs : " << distortion << std::endl;
      std::cout << "RMS reprojection error: " << rms_error << std::endl;
    }
  }